#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label visible
                                        ; outside this module
/**********************INTERRUPT VECTOR DECLARATIONS***************************/
        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    TIMER_A0_ISR            ; set vector for 'TIMER_A0_ISR' routine
        
        ORG     0FFDAh                  ; vector for PORT1
        DC16    PORT1_ISR               ; set vector for 'PORT1_ISR' routine
        
        ORG     0FFFEh                  ; vector for RESET
        DC16    init                    ; set reset vector to 'init' label

        ORG     01C00h
        
/*******************ARRAYS & GLOBAL VARIABLE DECLARATIONS**********************/      
;Digits      0     1     2     3     4     5    6    7      8     9
DigitH  db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xE7
DigitL  db 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00


state           DW      0   ; Tells us in what state we are currently at
                            ; In reference to state diagram developed
S1_Counter      DW      0   ; Used to count how many times we have pressed S1

/*******************************MAIN SETUP*************************************/
        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        

        bis.b   #0F9h, &P1DIR           ; Port 1.1/1.2 for button input, all other as output
        bis.b   #0FFh, &P2DIR           ; All Port 2 pins as output
	bis.b   #0FFh, &P9DIR           ; All Port 9 pins as output
        

	bis.b   #06h, &P1OUT		; P1.1/P1.2 Resistors enabled as pullup
        bis.b   #06h, &P1REN            ; resistor. Push is read as 0 and else 1

        bis.b   #06h, &P1IES            ; Int generated on high to low transition
        bis.b   #06h, &P1IE             ; Enable interrupt at P1.1/P1.2

        
;Objetivo: Prepara los segmentos del LCD Display
;Precondiciones: N/A
;Postcondiciones: El LCD sera listo para dibujar en el
;Autor: Fernando Bermudez
;Fecha: 14/abr/2021
LCD_Setup:
    	;Enable LCD segments 0 - 21; 26 - 43
    	mov.w   #0xffff, &LCDCPCTL0
    	mov.w   #0xfc3f, &LCDCPCTL1
    	mov.w   #0x0fff, &LCDCPCTL2

    	bis.w   #1,&LCDCCTL0
    	mov.w   #0x041e, &LCDCCTL0      ;Initialize LCD_C
    	mov.w   #0x0208, &LCDCVCTL      ;VLCD generated internally
    	mov.w   #0x8000, &LCDCCPCTL     ;Clock synchronization enabled 
    	mov.w   #2,&LCDCMEMCTL          ;Clear LCD memory
    	bis.w   #1,&LCDCCTL0            ;Turn LCD on
        
        call    #stateInitializer
        

UnlockGPIO:
        bic.w   #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on default
                                        ; high-impedance mode to activate
                                        ; previously configured port settings

        mov     #CCIE, &TA0CCTL0        ; Enable TACCR0 interrupt

        mov     #TASSEL_2+MC_1+ID_3, &TA0CTL  ;Set timer according to next table
	nop
        ; Uses SMCLK and up mode
        ; TASSELx        MCx (mode control)                IDx (input divider)
        ; 00 -> TACLK    00 -> Stop                        00 -> /1
        ; 01 -> ACLK     01 -> Up mode (up to TACCR0)      01 -> /2
        ; 10 -> SMCLK    10 -> Continuous (up to 0FFFFh)   02 -> /4
        ; 11 -> INCLK    11 -> Up/down (top on TACCR0)     03 -> /8

        ; period = cycles * divider / SMLCK
        ; Assuming SMLCK = 1 MHz, divider = 8 and period = 0.5 seg
        ; cycles = 62500.  With period = 0.5 LED turn on every 1 second
        mov     #62500, &TA0CCR0        ; Set the timer capture compare register 0

        bic.b   #0000110b, &P1IFG       ; To erase a flag raised before
               	                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.
	nop				; required befor enabling interrupts


        bis     #GIE+LPM0, SR           ; Enable interrupts and enter Low Power mode 0
                                        ; that doesn't disable timers
        nop                             ; Required after enabling interrupts

        

        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)
        
/******************************************************************************/

/**********************INTERRUPT SERVICE ROUTINES******************************/
;Objetivo: ISR Principal para los temporizadores 
;Precondiciones: 
;Postcondiciones: 
;Autor:  
;Fecha: ##/abr/2021
TIMER_A0_ISR:
        jmp finalizeInt
        
;Objetivo: ISR Principal para los botones 
;Precondiciones: P1IFG en el Bit 0 o 1 deberia cambiarse a 1
;Postcondiciones: Los flags de interrupciones se daran reset a 0
;Autor: Fernando Bermudez
;Fecha: 14/abr/2021    
PORT1_ISR:
        call    #sleep
        
        bic.b   #11111001b, &P1IFG	;Make sure buttons are pressed
        
        cmp.b   #00000100b, &P1IFG      ;if right button is pressed
        jz      S2_States
        
        cmp.b   #00000010b, &P1IFG      ;if left button is pressed
        jz      S1_States
        
        
        jmp     resetIntFlags           ;If no buttons were pressed, reset default
        
        jmp     finalizeInt
        
/***************************STATE SELECTORS************************************/
;Objetivo: Determinar a que estado de la aplicacion se debera mover 
;          si se presiona el boton S2
;Precondiciones: La variable state debe guardar el valor 0, 1, 2, 6 o 7
;Postcondiciones: La variable state sera cambiada cuando entre a la subrutina correspondiente
;Autor: Fernando Bermudez
;Fecha: 14/abr/2021
S2_States:  
        cmp     #0, state
        jz      drawRead                ;Move to state READ (1)

        cmp     #1, state
        jz      drawLog                 ;Move to state LOG (2)

        cmp     #2, state                      
        jz      drawRead                ;Move back to state READ (1)

        cmp     #6, state
        jz      save                    ;Move to state SAVE (7)

        cmp     #7, state
        jz      drawOption              ;Move to state OPTION (0)

;Objetivo: Determinar a que estado de la aplicacion se debera mover 
;          si se presiona el boton S1
;Precondiciones: La variable state debe guardar el valor 1, 2, 3, 4 o 7
;Postcondiciones: La variable state sera cambiada cuando entre a la subrutina correspondiente
;Autor: Fernando Bermudez
;Fecha: 14/abr/2021
S1_States:
        
        cmp     #1, state
        jz      recordPulse             ;Move to state Record Pulse (4)

        cmp     #4, state
        jz      heartBeat               ;Move to state HeartBeat (5)

        cmp     #2, state                      
        jz      displayLectures         ;Move to state Display Lectures (3)

        cmp     #3, state                      
        jz      displayLectures         ;Move back to state Display Lectures (3)

        cmp     #7, state
        jz      saveLectureFRAM         ;Move to state Save Lecture in FRAM (8)
        
/******************************************************************************/        

/***************************S1 STATES******************************************/
recordPulse:
        mov       #4, state
        jmp       resetIntFlags
        
heartBeat:
        mov       #5, state
        jmp       resetIntFlags
       
;Objetivo: Poner en la pantalla las ultimas 3 lecturas guardads en la memoria 
;Precondiciones: La variable S1_Counter debe ser menor que 4
;Postcondiciones: La variable state sera cambiada a 3 y S1_Counter sera incrementada o reseteada a 0,
;                 los flags de interrupciones se daran reset
;Autor: Fernando Bermudez
;Fecha: 14/abr/2021        
displayLectures:
        mov       #3, state
        
        mov.w     #2,&LCDCMEMCTL         ;Clear LCD memory
        
        inc       S1_Counter
        cmp       #4, S1_Counter         ; If we have finished displaying last
        jz        drawOption             ; 3 Lectures, return back to state OPTION (0)
        
        ;If not, display the latest lecture

        /*Dummy Display*/
        mov.b     #0xF1,&0xA32                    ;B
        mov.b     #0x50,&0xA33
      
        mov.b     #0xCF,&0xA2E                    ;P

        mov.b     #0x6C,&0xA27                    ;M
        mov.b     #0xA0,&0xA28
        
        jmp       resetIntFlags
        
saveLectureFRAM:
        mov       #8, state
        mov.w     #2,&LCDCMEMCTL          ;Clear LCD memory

        jmp       drawOption
/******************************************************************************/

/***************************S2 STATES******************************************/
save:
        mov.w     #2,&LCDCMEMCTL          ;Clear LCD memory

        mov       #0xEF, &0xA23
        mov       #0x9F, &0xA25           
        jmp       resetIntFlags
        
;Objetivo: Cambiar al estado READ (1) 
;Precondiciones: La variable state debe guardar el valor 0 o 2
;Postcondiciones: La variable state sera cambiada a 1, los flags de interrupciones se daran reset
;Autor: Fernando Bermudez
;Fecha: 14/abr/2021    
drawRead:
        mov       #1, state
        mov.w     #2,&LCDCMEMCTL          ;Clear LCD memory

        mov.b     #0xCF, &0xA29           ;R
        mov.b     #0x02, &0xA2A           
        
        mov.b     #0x9F, &0xA25           ;E
        mov.b     #0xEF, &0xA23           ;A

        mov.b     #0xF0, &0xA32           ;D
        mov.b     #0X50, &0xA33           
        
        jmp       resetIntFlags
        
;Objetivo: Cambiar al estado LOG (2) 
;Precondiciones: La variable state debe guardar el valor 0 o 1
;Postcondiciones: La variable state sera cambiada a 2, los flags de interrupciones se daran reset
;Autor: Fernando Bermudez
;Fecha: 14/abr/2021       
drawLog:
        mov       #2, state
        mov.w     #2,&LCDCMEMCTL          ;Clear LCD memory
        mov.b     #0x1C, &0xA29           ;L
        mov.b     #0xFC, &0xA25           ;O
        mov.b     #0xBD, &0xA23           ;G
        jmp       resetIntFlags
        
;Objetivo: Cambiar al estado OPTION (0) 
;Precondiciones: La variable state debe guardar el valor 3, 7 o 8
;Postcondiciones: La variable state sera cambiada a 0, los flags de interrupciones se daran reset,
;                 La variable S1_Counter se le dara reset
;Autor: Fernando Bermudez
;Fecha: 14/abr/2021      
drawOption:
        mov       #0, state               ;Reset state indicator
        mov       #0, S1_Counter          ;Reset Log Lecture counter 
        mov.b     #0xFC, &0xA29           ;O
        mov.b     #0xCF, &0xA25           ;P

        mov.b     #0x80, &0xA23           ;T
        mov.b     #0x50, &0xA24
        
        mov.b     #0x90, &0xA32           ;I
        mov.b     #0x50, &0xA33
        
        mov.b     #0xFC, &0xA2E           ;O

        mov.b     #0x6C, &0xA27           ;N
        mov.b     #0x82, &0xA28
        
        jmp       resetIntFlags
        
/******************************************************************************/

/**********************HELPER SUBROUTINES**************************************/
;Objetivo: Inicializa al estado OPTION (0) 
;Precondiciones: N/A
;Postcondiciones: La variable state sera cambiada a 0
;Autor: Fernando Bermudez
;Fecha: 14/abr/2021
stateInitializer:
        mov       #0, state               ;Force state indicator to 0
        mov.b     #0xFC, &0xA29           ;O
        mov.b     #0xCF, &0xA25           ;P

        mov.b     #0x80, &0xA23           ;T
        mov.b     #0x50, &0xA24
        
        mov.b     #0x90, &0xA32           ;I
        mov.b     #0x50, &0xA33
        
        mov.b     #0xFC, &0xA2E           ;O

        mov.b     #0x6C, &0xA27           ;N
        mov.b     #0x82, &0xA28
        
        jmp        return

resetIntFlags:
        bic.b      #00000110b, &P1IFG	;Reset Interrupt Flag
        nop
	xor 	   #CCIE, &TA0CCTL0
	nop
        
        jmp        finalizeInt   
  
  
sleep:
        mov     #65535, R12
iterSleep:
        dec     R12
        jz      return      
        jmp     iterSleep
      
finalizeInt:
        reti
return:        
        ret
/******************************************************************************/
        END
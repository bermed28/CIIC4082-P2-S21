#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module

        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    TIMER_A0_ISR            ; set vector for 'TIMER_A0_ISR' routine
        
        ORG     0FFDAh                  ; vector for PORT1
        DC16    PORT1_ISR               ; set vector for 'PORT1_ISR' routine
        
        ORG     0FFFEh                  ; vector for RESET
        DC16    init                    ; set reset vector to 'init' label

        ORG     01C00h
;Digits      0     1     2     3     4     5    6    7      8     9
DigitH  db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xE7
DigitL  db 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00


stsate  DW      0                       ; TIMER_A0 interrupts counter

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        

        bis.b   #0F9h, &P1DIR           ; Port 1.1/1.2 for button input, all other as output
        bis.b   #0FFh, &P2DIR           ; All Port 2 pins as output
	bis.b   #0FFh, &P9DIR           ; All Port 9 pins as output
        

	bis.b   #06h, &P1OUT		; P1.1/P1.2 Resistors enabled as pullup
        bis.b   #06h, &P1REN            ; resistor. Push is read as 0 and else 1

        bis.b   #06h, &P1IES            ; Int generated on high to low transition
        bis.b   #06h, &P1IE             ; Enable interrupt at P1.1/P1.2

        clr     R6

LCD_Setup:
    	;Enable LCD segments 0 - 21; 26 - 43
    	mov.w   #0xffff, &LCDCPCTL0
    	mov.w   #0xfc3f, &LCDCPCTL1
    	mov.w   #0x0fff, &LCDCPCTL2

    	bis.w   #1,&LCDCCTL0
    	mov.w   #0x041e, &LCDCCTL0      ;Initialize LCD_C
    	mov.w   #0x0208, &LCDCVCTL      ;VLCD generated internally
    	mov.w   #0x8000, &LCDCCPCTL     ;Clock synchronization enabled 
    	mov.w   #2,&LCDCMEMCTL          ;Clear LCD memory
    	bis.w   #1,&LCDCCTL0            ;Turn LCD on
        
        call    #drawOption
        

UnlockGPIO:
        bic.w   #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on default
                                        ; high-impedance mode to activate
                                        ; previously configured port settings

        mov     #CCIE, &TA0CCTL0        ; Enable TACCR0 interrupt

        mov     #TASSEL_2+MC_1+ID_3, &TA0CTL  ;Set timer according to next table
	nop
        ; Uses SMCLK and up mode
        ; TASSELx        MCx (mode control)                IDx (input divider)
        ; 00 -> TACLK    00 -> Stop                        00 -> /1
        ; 01 -> ACLK     01 -> Up mode (up to TACCR0)      01 -> /2
        ; 10 -> SMCLK    10 -> Continuous (up to 0FFFFh)   02 -> /4
        ; 11 -> INCLK    11 -> Up/down (top on TACCR0)     03 -> /8

        ; period = cycles * divider / SMLCK
        ; Assuming SMLCK = 1 MHz, divider = 8 and period = 0.5 seg
        ; cycles = 62500.  With period = 0.5 LED turn on every 1 second
        mov     #62500, &TA0CCR0        ; Set the timer capture compare register 0

        bic.b   #0000110b, &P1IFG       ; To erase a flag raised before
               	                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.
	nop				; required befor enabling interrupts


        bis     #GIE+LPM0, SR           ; Enable interrupts and enter Low Power mode 0
                                        ; that doesn't disable timers
        nop                             ; Required after enabling interrupts

        

        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)
        

TIMER_A0_ISR:
        jmp fin

fin:
        reti
        
        
PORT1_ISR:
        call    #sleep
        bic.b   #11111001b, &P1IFG	;Make Sure buttons are pressed

        cmp.b   #00000100b, &P1IFG      ;if right button is pressed
        jz      optionSelector
        
        cmp.b   #00000010b, &P1IFG      ;if left button is pressed
        jz      operationSelector
        
       
	xor.b  	#0x80,&P9OUT	        ;Toggle green LED
        jmp     resetIntFlags
        
        jmp     fin


resetIntFlags:
        bic.b      #00000110b, &P1IFG	;Reset Interrupt Flag
        nop
	xor 	   #CCIE, &TA0CCTL0
	nop
        
        jmp        fin   
  
  
sleep:
        mov     #65535, R12
iterSleep:
        dec     R12
        jz      return      
        jmp     iterSleep
        
optionSelector:
        inc     R6
        cmp     #1,R6
        jz      drawRead
        cmp     #2,R6
        jz      drawLog
        clr     R6
        jmp     optionSelector
     
     
operationSelector:
        cmp     #1, R6
        jz      drawReadBPM
        
        cmp     #2, R6
        jz      drawLogBPM
        
        jmp     resetIntFlags    
        
drawReadBPM:
        mov.w     #2,&LCDCMEMCTL          ;Clear LCD memory

        mov.b     #0xF1,&0xA32                    ;B
        mov.b     #0x50,&0xA33
      
        mov.b     #0xCF,&0xA2E                    ;P

        mov.b     #0x6C,&0xA27                    ;M
        mov.b     #0xA0,&0xA28
        
        jmp       resetIntFlags
        
drawLogBPM:
        mov.w     #2,&LCDCMEMCTL          ;Clear LCD memory

        mov.b     #0x1C,&0xA29                    ;L
        mov.b     #0x00,&0xA2A
        
        mov.b     #0xF1,&0xA32                    ;B
        mov.b     #0x50,&0xA33
      
        mov.b     #0xCF,&0xA2E                    ;P

        mov.b     #0x6C,&0xA27                    ;M
        mov.b     #0xA0,&0xA28
        jmp       resetIntFlags
        
drawRead:

        mov.w     #2,&LCDCMEMCTL          ;Clear LCD memory

        mov.b     #0xCF, &0xA29           ;R
        mov.b     #0x02, &0xA2A           
        
        mov.b     #0x9F, &0xA25           ;E
        mov.b     #0xEF, &0xA23           ;A

        mov.b     #0xF0, &0xA32           ;D
        mov.b     #0X50, &0xA33           
        
        jmp       resetIntFlags
        
drawLog:
        mov.w     #2,&LCDCMEMCTL          ;Clear LCD memory
        mov.b     #0x1C, &0xA29           ;L
        mov.b     #0xFC, &0xA25           ;O
        mov.b     #0xBD, &0xA23           ;G
        jmp       resetIntFlags
        
drawOption:
        mov.b     #0xFC, &0xA29           ;O
        mov.b     #0xCF, &0xA25           ;P

        mov.b     #0x80, &0xA23           ;T
        mov.b     #0x50, &0xA24
        
        mov.b     #0x90, &0xA32           ;I
        mov.b     #0x50, &0xA33
        
        mov.b     #0xFC, &0xA2E           ;O

        mov.b     #0x6C, &0xA27           ;N
        mov.b     #0x82, &0xA28
        
return:        ret

        END